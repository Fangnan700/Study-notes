---
title: 数据结构与算法笔记
date: 2022-05-10 21:46:56
tags: [数据结构]
keywords: 数据结构
categories:
- 数据结构与算法
image: 
top: 0
---

一些数据结构与算法的笔记。

<!-- more -->



# 一、数据结构与算法思维导图

![思维导图](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/思维导图.jpg)



# 二、数据结构的基本概念

## 基本概念

**数据**是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。

**数据元素**是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。

**数据对象**是性质相同的数据元素的集合，是数据的一个子集。

**数据结构**是相互之间存在一种或多种特定关系的数据元素的集合。

通常有以下四类基本结构：集合、线性结构、树形结构、图状结构或网状结构。

**存储结构**是数据结构在计算机中的表示。

**数据类型**是一个值的集合和定义在这个值集上的一组操作的总称。

**抽象数据类型**是指一个数学模型以及定义在该模型上的一组操作

可细分为：原子类型、固定聚合类型、可变聚合类型。

常用的数据结构类型：集合、线性、树形、图状。

数据结构包括**逻辑结构**和**存储结构**：

**逻辑结构**：数据元素之间的关系
**存储结构**：数据结构在计算机中的表示。存储结构分为：顺序存储结构和链式存储结构。

**算法**：算法是对特定问题求解步骤的一种描述，算法具有如下特性：有穷性、确定性、可行性、输入、输出。

**算法的度量**：时间复杂度、空间复杂度

衡量一个算法是否优秀，则主要从以下几点考虑：正确性，可读性，健壮性，时间复杂度，空间复杂度



```
数据结构的三要素：
1、逻辑结构
2、存储结构
3、数据的运算
```





## 时间复杂度的分析

### 1.大O复杂度表示法

公式：

```
T(n)=O[f(n)]
```

T(n)表示代码执行的时间; n表示数据规模的大小; f(n) 表示每行代码执行的次数总和。

公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。

### 2.复杂度分析法则

1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

### **3.时间复杂度分析**

1）只关注循环执行次数最多的一段代码

2）加法法则：总复杂度等于量级最大的那段代码的复杂度

3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

![时间复杂度](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/时间复杂度.png)

常见的时间复杂度：

1、**多项式阶：**随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。如：

O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）

2、**非多项式阶：**随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。如：

O(2^n)（指数阶）、O(n!)（阶乘阶）





# 三、线性表

线性表:   线性表就是数据排成像一条线一样的结构。

每个线性表上的数据最多只有前和后两个方向。

常见的线性表结构：数组，链表、队列、栈。

线性表强调元素在逻辑上紧密相邻，所以首先想到用**数组**存储。

## 线性表的顺序存储结构（顺序表）

### 基本概念

**数组（Array）**是一种线性表数据结构。它用一组**连续**的内存空间，来存储一组具有**相同类型**的数据。

优点：存储密度大、可以随机存取表中任一元素。

缺点：删除，插入数据效率低。对内存空间要求高，需要一块连续的内存空间。

**数组根据下标随机访问元素的原理：**

通过寻址公式：**a[i]_address = base_address + i * data_type_size**
其中 data_type_size 表示数组中每个元素的大小，base_address 是首元素地址，i 是数组下标。

**数组元素插入和删除低效的原因：**

1>插入：

若要将一元素 x 插入数组arr[n]的第k个位置，则第k个元素到第n个元素均需后移一位。

分为两种情况：

①数组元素无序：最好时间复杂度为O(1)

直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。

②数组元素有序：最坏时间复杂度为O(n)

数组元素插入的平均复杂度为O(n)

2>删除：与插入的情况类似。

最好时间复杂度为O(1)，最坏时间复杂度为O(n)，平均时间复杂度为O(n)

提高数组元素删除效率的方法——JVM标记清除垃圾回收算法：

记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。

### 使用动态数组实现顺序表

普通数组的长度一旦确定便不可修改，动态数组就是在普通数组的基础上，增加了一个可修改长度的功能，即动态分配，C语言中使用realloc()函数实现。

**代码实现如下：**

1. 创建顺序表数据结构

   ```c
   typedef struct olNode {
       int *head;
       int length;
       int size;
   }olNode;
   ```

2. 初始化顺序表

   ```c
   olNode init(olNode OL, int size) {
       OL.head = (int *)malloc(size*sizeof(int));
       OL.length = 0;
       OL.size = size;
       return OL;
   }
   ```

3. 遍历顺序表

   ```c
   void display(olNode OL) {
       for(int i = 0; i < OL.length; i++) {
           printf("%d ", OL.head[i]);
       }
       printf("\n");
   }
   ```

4. 向顺序表的指定位置插入元素

   ```c
   olNode insert(olNode OL, int addr, int elem) {
       if(OL.length == OL.size) {
           OL.head = (int *)realloc(OL.head, (OL.size + 1)*sizeof(int));
       }
       for(int i = OL.length-1; i > addr; i--) {
           OL.head[i+1] = OL.head[i];
       }
       OL.head[addr] = elem;
       OL.length += 1;
       return OL;
   }
   ```

5. 删除顺序表指定位置的元素

   ```c
   olNode delete(olNode OL, int addr) {
       for(int i = addr; i < OL.length - 1; i++) {
           OL.head[i] = OL.head[i+1];
       }
       OL.length -= 1;
       return OL;
   }
   ```

6. 修改顺序表中的元素

   ```c
   olNode correct(olNode OL, int elem, int data) {
       for(int i = 0; i < OL.length; i++) {
           if(OL.head[i] == elem) {
               OL.head[i] = data;
           }
       }
       return OL;
   }
   ```

7. 查询顺序表指定位置的元素

   ```c
   int inquire(olNode OL, int addr) {
       for(int i = 0; i < OL.length; i++) {
           if(i == addr) {
               return OL.head[i];
           }
       }
   }
   ```

8. 测试代码

   ```c
   int main() {
       olNode OL;
       OL = init(OL, 10);
       printf("向顺序表中插入元素0～9:\n");
       for(int i = 0; i < 10; i++) {
           OL = insert(OL, i, i);
       }
       display(OL);
       printf("删除顺序表中下表为3的元素：\n");
       OL = delete(OL, 3);
       display(OL);
       printf("把顺序表中的元素5修改为0:\n");
       OL = correct(OL, 5, 0);
       display(OL);
       printf("查询顺序表中下标为7的元素：\n");
       printf("%d\n", inquire(OL, 7));
       return 0;
   }
   ```

9. 测试结果

   ![image-20220514113008761](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220514113008761.png)

   



## 线性表的链式存储结构（链表）

### 基本概念

**数据域**：存储元素数值数据的存储位置

**指针域**：存储直接后继结点或直接前驱节点地址的存储位置

**结点**：数据元素的存储映像， 由数据域和指针域两部分组成

**链表**： n 个结点由指针链组成一个链表，它是线性表的链式存储映像，称为线性表的链式存储结构

**头指针**：是指向链表中第一个结点的指针

**头结点**：是在链表的首元结点之前附设的一个结点，数据域内只放空表标志和表长等信息

**首元结点**：是指链表中存储第一个数据元素的结点

链表（Linked list）也是一种线性表。

它的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储。

![数组和链表的内存分布](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/数组和链表的内存分布.jpg)

链表中的每一个内存块被称为节点Node。

节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。

**链表的特点：**

1、插入、删除数据效率高，只需更改指针指向，时间复杂度为O(1)

![链表的插入和删除](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/链表的插入和删除.jpg)

2、随机访问效率低，需要从链头至链尾进行遍历，时间复杂度为O(n)

3、和数组相比，内存空间消耗更大，每个节点都需要额外的空间存储指针。

**常用链表**

**1、单链表**

![单链表](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/单链表.jpg)

每个节点只包含一个指针，即**后继指针**。

单链表有两个特殊的节点，即首节点和尾节点。首节点地址表示整条链表，尾节点的后继指针指向空地址NULL。

单链表插入和删除节点的时间复杂度为O(1），查找的时间复杂度为O(n)。

**2、循环链表**

![循环链表](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/循环链表.jpg)

除了**尾节点的后继指针指向首节点的地址**外均与单链表一致。

**3、双向链表**

![双向链表](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/双向链表.jpg)

节点除了存储数据外，还有两个指针：**前驱指针 prev** 和**后继指针 next**。

首节点的前驱指针prev和尾节点的后继指针均指向空地址。

和单链表相比，存储相同的数据，需要消耗更多的存储空间。

性能分析：插入和删除操作

①给定数据值：单链表和双向链表均需要从头到尾遍历查找，时间复杂度为O(n)

②给定节点地址：单链表需要从头到尾遍历查找指定节点的前驱节点，时间复杂度为O(n)，双向链表可以直接找到指定节点的前驱节点，时间复杂度为O(1)

对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

**4、双向循环链表**

![双向循环链表](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/双向循环链表.jpg)



和双向链表类似，除了节点有两个指针：**前驱指针 prev** 和**后继指针 next **外，**首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点**。

**数组和链表的对比**

![数组和链表的对比](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/数组和链表的对比.jpg)

### 链表的基本操作

#### 1、单链表

**创建单链表节点结构**

```c
typedef struct singleList {
    int data;
    struct singleList *next;
}singleList;
```

**初始化单链表**

```c
singleList *init() {
    singleList *head = (singleList *)malloc(sizeof(singleList));
    head -> data = 0;
    head -> next = NULL;
    return head;
}
```

**向单链表中插入元素**

```c
//头插法
singleList *reverse_insert(singleList *head, int data) {
    singleList *node = (singleList *)malloc(sizeof(singleList));
    node -> data = data;
    node -> next = head -> next;
    head -> next = node;
    return head;
}

//尾插法
singleList *positive_insert(singleList *head, int data) {
    singleList *p = head;
    while(p -> next) {
        p = p -> next;
    }
    singleList *q = (singleList *)malloc(sizeof(singleList));
    q -> data = data;
    q -> next = NULL;
    p -> next = q;
    return head;
}
```

**删除单链表中的指定元素**

```c
singleList *delete(singleList *head, int data) {
    singleList *p = head, *t;
    singleList *q = head -> next;
    while(q) {
        if(q -> data == data) {
            t = q;
            q = q -> next;
            p -> next = q;
            free(t);
        }
        else {
            q = q -> next;
            p = p -> next;
        }
    }
    return head;
}
```

**修改单链表中的指定元素**

```c
singleList *correct(singleList *head, int data_before, int data_after) {
    singleList *t = head -> next;
    while(t) {
        if(t -> data == data_before) {
            t -> data = data_after;
        }
        t = t -> next;
    }
    return head;
}
```

**查找单链表中的指定元素**

```c
int inquire(singleList *head, int data) {
    singleList *t = head -> next;
    while(t) {
        if(t -> data == data)
            return t -> data;
        t = t -> next;
    }
}
```

**销毁单链表**

```c
void destroy(singleList *head) {
    singleList *p = head, *q = head -> next;
    while(q) {
        free(p);
        p = q;
        q = q -> next;
    }
    printf("单链表已销毁\n\n");
}
```

**遍历单链表**

```c
void display(singleList *head) {
    singleList *t = head -> next;
    while(t) {
        printf("%d ", t -> data);
        t = t -> next;
    }
    printf("\n");
}
```

**测试代码**

```c
int main() {
    singleList *head = init();
    printf("使用头插法向单链表中插入元素0～9：\n");
    for(int i = 0; i < 10; i++) {
        head = reverse_insert(head, i);
    }
    display(head);
    printf("删除单链表中值为5的元素：\n");
    head = delete(head, 5);
    display(head);
    printf("将单链表中值为7的元素修改为值等于0：\n");
    head = correct(head, 7, 0);
    display(head);
    printf("查询单链表中值为3的元素：\n");
    printf("%d\n", inquire(head, 3));
    printf("销毁单链表\n");
    destroy(head);
    
    head = init();
    printf("使用尾插法向单链表中插入元素0～9：\n");
    for(int i = 0; i < 10; i++) {
        head = positive_insert(head, i);
    }
    display(head);
    printf("删除单链表中值为2的元素：\n");
    head = delete(head, 2);
    display(head);
    printf("将单链表中值为9的元素修改为值等于0：\n");
    head = correct(head, 9, 0);
    display(head);
    printf("查询单链表中值为6的元素：\n");
    printf("%d\n", inquire(head, 6));
    printf("销毁单链表\n");
    destroy(head);
    return 0;
}
```

**测试结果**

![image-20220514131637681](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220514131637681.png)



#### 2、循环链表

**使用循环链表实现约瑟夫环**

约瑟夫环问题：已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。例如：

![image-20220515141540598](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220515141540598.png)

假设此时圆周周围有 5 个人，要求从编号为 3 的人开始顺时针数数，数到 2 的那个人出列。

出列顺序依次为：

- 编号为 3 的人开始数 1，然后 4 数 2，所以 4 先出列；
- 4 出列后，从 5 开始数 1，1 数 2，所以 1 出列；
- 1 出列后，从 2 开始数 1，3 数 2，所以 3 出列；
- 3 出列后，从 5 开始数 1，2 数 2，所以 2 出列；
- 最后只剩下 5 自己，所以 5 胜出。

实现代码如下：

1. 定义循环链表结构体

   ```c
   typedef struct circularList {
       int number;
       struct circularList *next;
   }circularList;
   ```

2. 初始化循环链表

   ```c
   circularList *init(int n) {
       int i = 0;
       circularList *head = NULL;
       circularList *circular_point = NULL;
       head = (circularList *)malloc(sizeof(circularList));
       head -> number = 1;
       head -> next = NULL;
       circular_point = head;
       for(i = 2; i <= n; i++) {
           circularList *body = (circularList *)malloc(sizeof(circularList));
           body -> number = i;
           body -> next = NULL;
           circular_point -> next = body;
           circular_point = circular_point -> next;
       }
       circular_point -> next = head;
       return head;
   }
   ```

3. 寻找节点

   ```c
   void find_kill(circularList *head, int k, int m) {
       //找到编号为k的节点
       circularList *tail = NULL;
       circularList *circular_point = head;    //工作指针
       while(circular_point -> number != k) {
           tail = circular_point;
           circular_point = circular_point -> next;
       }
       //找到报m的节点出列
       while(circular_point -> next != circular_point) {
           for(int i = 1; i < m; i++) {
               tail = circular_point;
               circular_point = circular_point -> next;
           }
           tail -> next = circular_point -> next;
           printf("出列编号：%d\n", circular_point -> number);
           free(circular_point);
           circular_point = tail -> next;
       }
       printf("出列编号：%d\n", circular_point -> number);
       free(circular_point);
   }
   ```

4. 测试代码

   ```c
   int main() {
       int n = 5;	//循环链表中共5个人
       int k = 3;	//从第3个人开始报数
       int m = 2;	//报到2的人出列
       circularList *head = init(n);
       find_kill(head, k, m);
       return 0;
   }
   ```
   
5. 测试结果

   ![image-20220515144509379](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220515144509379.png)

   ![image-20220515223030872](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220515223030872.png)

#### 3、双向链表

1. 创建双向链表节点结构体

   ```c
   typedef struct doublyList {
       int data;
       struct doublyList *prev;
       struct doublyList *next;
   }doublyList;
   ```
   
2. 初始化双向链表（向链表中填入数字1～n）

   ```c
   doublyList *init(int n) {
       doublyList *head = (doublyList *)malloc(sizeof(doublyList));
       head -> data = 0;
       head -> prev = NULL;
       head -> next = NULL;
       for(int i = 1; i <= n; i++) {
           doublyList *p = head;
           while(p -> next) {
               p = p -> next;
           }
           doublyList *node = (doublyList *)malloc(sizeof(doublyList));
           node -> data = i;
           node -> prev = p;
           p -> next = node;
       }
       return head;
   }
   ```

3. 在双向链表的指定位置插入元素

   ```c
   doublyList *insert(doublyList *head, int addr, int data) {
       doublyList *p = head;
       int i = 0;
       while(i < addr - 1) {
           p = p -> next;
           i++;
       }
       doublyList *node = (doublyList *)malloc(sizeof(doublyList));
       node -> data = data;
       node -> prev = p;
       node -> next = p -> next;
       p -> next = node;
       return head;
   }
   ```

4. 删除双向链表中指定值的节点

   ```c
   doublyList *delete(doublyList *head, int data) {
       doublyList *p = head, *q;
       while(p -> next && p -> next -> data != data) {
           p = p -> next;
       }
       q = p -> next;
       p -> next = p -> next -> next;
       p -> next -> next -> prev = p;
       return head;
   }
   ```

5. 修改双向链表中的指定值

   ```c
   doublyList *correct(doublyList *head, int data_before, int data_after) {
       doublyList *p = head -> next;
       while(p -> data != data_before) {
           p = p -> next;
       }
       p -> data = data_after;
       return head;
   }
   ```

6. 查询双向链表指定位置的值

   ```c
   int inquire(doublyList *head, int addr) {
       doublyList *p = head;
       for(int i = 0; i <= addr - 1; i++) {
           p = p -> next;
       }
       return p -> data;
   }
   ```

7. 正序遍历

   ```c
   void positive_display(doublyList *head) {
       doublyList *p = head -> next;
       while(p) {
           printf("%d ", p -> data);
           p = p -> next;
       }
       printf("\n");
   }
   ```

8. 逆序遍历

   ```c
   void reverse_display(doublyList *head) {
       doublyList *p = head;
       while(p -> next) {
           p = p -> next;
       }
       while(p -> prev != NULL) {
           printf("%d ", p -> data);
           p = p -> prev;
       }
       printf("\n");
   }
   ```

9. 测试代码

   ```c
   int main() {
       printf("建立一个双向链表并填入数字1～10\n");
       doublyList *head = init(10);
       printf("正序遍历\n");
       positive_display(head);
       printf("逆序遍历\n");
       reverse_display(head);
       printf("向双向链表正向第6位插入数字-1\n");
       head = insert(head, 6, -1);
       positive_display(head);
       printf("删除双向链表中的元素8\n");
       head = delete(head, 8);
       positive_display(head);
       printf("将双向链表中的4改为-2\n");
       head = correct(head, 4, -2);
       positive_display(head);
       printf("查找双向链表正向第3位的值\n");
       printf("%d\n", inquire(head, 3));
       return 0;
   }
   ```

10. 测试结果

   ![image-20220516001234306](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516001234306.png)

   

#### 4、双向循环链表



# 四、栈和队列

## 栈的基本概念

**栈的定义**

同顺序表和链表一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构。栈只能在表的一端（栈顶）进行插入和删除运算。

**栈的存储结构**

用顺序栈或链栈存储均可，但以顺序栈更常见。

**运算规则**

先进后出，后进先出。

![栈](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/栈.png)

## 栈的基本操作

### 顺序栈

顺序栈：用顺序表实现栈的存储结构。基本操作与顺序表的操作基本一致，但要遵循先进后出、后进先出的规则，只能在栈顶（顺序表一端）操作。

**使用动态数组实现顺序栈**

1. 定义顺序栈结构体

   ```c
   typedef struct orderStack {
       int *head;
       int length;
       int size;
   }orderStack;
   ```

2. 初始化顺序栈

   ```c
   orderStack init(orderStack OS, int size) {
       OS.head = (int *)malloc(size*sizeof(int));
       OS.length = 0;
       OS.size = size;
       return OS;
   }
   ```

3. 入栈

   ```c
   orderStack enstack(orderStack OS, int elem) {
       if(OS.length == OS.size) {
           OS.head = (int *)realloc(OS.head, (OS.size+1)*sizeof(int));
           OS.size += 1;
       }
       for(int i = OS.length; i > 0; i--) {
           OS.head[i] = OS.head[i - 1];
       }
       OS.head[0] = elem;
       OS.length += 1;
       return OS;
   }
   ```

4. 出栈

   ```c
   orderStack destack(orderStack OS) {
       if(OS.length != 0) {
           printf("%d出栈\n", OS.head[0]);
           for(int i = 0; i < OS.length; i++) {
               OS.head[i] = OS.head[i + 1];
           }
           OS.length -= 1;
       }
       return OS;
   }
   ```

5. 遍历栈

   ```c
   void display(orderStack OS) {
       for(int i = 0; i < OS.length; i++) {
           printf("%d ", OS.head[i]);
       }
       printf("\n");
   }
   ```

6. 测试代码

   ```c
   int main() {
       printf("初始化栈并将0～9依次入栈\n");
       orderStack OS;
       OS = init(OS, 10);
       for(int i = 0; i < 10; i++) {
           OS = enstack(OS, i);
       }
       display(OS);
       printf("出栈\n");
       for(int i = 0; i < 10; i++) {
           destack(OS);
       }
       printf("出栈完成\n");
       return 0;
   }
   ```

7. 测试结果

   ![image-20220516121250436](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516121250436.png)
   
   ![image-20220516093424165](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516093424165.png)



### 链式栈

1. 定义链式栈节点结构

   ```c
   typedef struct chainStack {
       int data;
       struct chainStack *next;
   }chainStack;
   ```

2. 初始化链式栈

   ```c
   chainStack *init() {
       chainStack *head = (chainStack *)malloc(sizeof(chainStack));
       head -> data = 0;
       head -> next = NULL;
       return head;
   }
   ```

3. 入栈

   ```c
   chainStack *enstack(chainStack *head, int data) {
       chainStack *node = (chainStack *)malloc(sizeof(chainStack));
       node -> data = data;
       node -> next = head -> next;
       head -> next = node;
       return head;
   }
   ```

4. 出栈

   ```c
   chainStack *destack(chainStack *head) {
       chainStack *node = head -> next;
       head -> next = head -> next -> next;
       printf("%d出栈\n", node -> data);
       free(node);
       return head;
   }
   ```

5. 遍历栈

   ```c
   void display(chainStack *head) {
       chainStack *node = head -> next;
       while(node) {
           printf("%d ",node -> data);
           node = node -> next;
       }
       printf("\n");
   }
   ```

6. 测试代码

   ```c
   int main() {
       printf("初始化链栈并将0～9以此入栈\n");
       chainStack *head = init();
       for(int i = 0; i < 10; i++) {
           head = enstack(head, i);
       }
       display(head);
       printf("将链栈中的元素依次出栈\n");
       for(int i = 0; i < 10; i++) {
           head = destack(head);
           display(head);
       }
   }
   ```

7. 测试结果

   ![image-20220516123842721](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516123842721.png)

![image-20220516123924358](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516123924358.png)





## 队的基本概念

**队列的定义**

只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表。

**运算规则**

先进先出，后进后出。

![队列](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/队列.png)

**基于数组的队列（顺序队）**

利用两个指针：一个**头指针(head)**，**一个尾指针(tail)**。

head指针始终指向队首，tail指针始终指向最后一个元素的下一个单元。

入队：head指针不动，tail指针后移。

![入队](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/入队.png)

出队：tail指针不动，head指针后移。

![出队](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/出队.png)

当tail指针移动到数组末端时，触发一次数据的整体搬移，将head和tail指针之间的元素整体搬移至数组头部。

![数据搬移](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/数据搬移.png)



**基于链表的队列（链式队）**

实现方法与数组类似，也需要两个指针（head和tail）

入队和出队时，指针在逻辑连接的节点间移动。类比在数组中的不同位置间移动。



## 队的基本操作

### 普通队列

#### 顺序队

使用动态数组实现顺序队的基本操作。

1. 定义顺序队的数据结构

   ```c
   typedef struct orderQueue {
       int *head;
       int length;
       int size;
   }orderQueue;
   ```

2. 初始化顺序队

   ```c
   orderQueue init(orderQueue OQ, int size){
       OQ.head = (int *)malloc(size*sizeof(int));
       OQ.length = 0;
       OQ.size = size;
       return OQ;
   }
   ```

3. 入队

   ```c
   orderQueue enqueue(orderQueue OQ, int elem) {
       if(OQ.length == OQ.size) {
           OQ.head = (int *)realloc(OQ.head, (OQ.size+1)*sizeof(int));
       }
       int i = 0;
       while(i < OQ.length)
           i++;
       OQ.head[i] = elem;
       OQ.length += 1;
       return OQ;
   }
   ```

4. 出队

   ```c
   orderQueue dequeue(orderQueue OQ) {
       int i = 0;
       printf("%d出队\n", OQ.head[i]);
       for(; i < OQ.length - 1; i++) {
           OQ.head[i] = OQ.head[i + 1];
       }
       OQ.length -= 1;
       return OQ;
   }
   ```

5. 遍历队

   ```c
   void display(orderQueue OQ) {
       for(int i = 0; i < OQ.length; i++) {
           printf("%d ", OQ.head[i]);
       }
       printf("\n");
   }
   ```

6. 测试代码

   ```c
   int main() {
       printf("初始化链式队并将0～9依次入队\n");
       orderQueue OQ;
       OQ = init(OQ, 10);
       for(int i = 0; i < 10; i++) {
           OQ = enqueue(OQ, i);
       }
       display(OQ);
       printf("将顺序队中的元素依次出队\n");
       for(int i = 0; i < 10; i++) {
           OQ = dequeue(OQ);
           display(OQ);
       }
       return 0;
   }
   ```

7. 测试结果

   ![image-20220516130853612](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516130853612.png)



#### 链式队

使用链表实现队列的基本操作。

1. 定义链式队节点的数据结构

   ```c
   typedef struct chainQueue {
       int data;
       struct chainQueue *next;
   }chainQueue;
   ```

2. 初始化链式队

   ```c
   chainQueue *init() {
       chainQueue *head = (chainQueue *)malloc(sizeof(chainQueue));
       head -> data = 0;
       head -> next = NULL;
       return head;
   }
   ```

3. 入队

   ```c
   chainQueue *enqueue(chainQueue *head, int data) {
       chainQueue *prev = head;
       while(prev -> next) {
           prev = prev -> next;
       }
       chainQueue *node = (chainQueue *)malloc(sizeof(chainQueue));
       node -> data = data;
       node -> next =  prev -> next;
       prev -> next = node;
       return head;
   }
   ```

4. 出队

   ```c
   chainQueue *dequeue(chainQueue *head) {
       chainQueue *node = head -> next;
       printf("%d出队\n", node -> data);
       head -> next = head -> next ->next;
       free(node);
       return head;
   }
   ```

5. 遍历队

   ```c
   void display(chainQueue *head) {
       chainQueue *node = head -> next;
       while(node) {
           printf("%d ", node -> data);
           node = node -> next;
       }
       printf("\n");
   }
   ```

6. 测试代码

   ```c
   int main() {
       printf("初始化链式队并将0~9依次入队\n");
       chainQueue *head = init();
       for(int i = 0; i < 10; i++) {
           head = enqueue(head, i);
       }
       display(head);
       printf("将链式队中的元素依次出队\n");
       for(int i = 0; i < 10; i++) {
           head = dequeue(head);
           display(head);
       }
       return 0;
   }
   ```

7. 测试结果

   ![image-20220516132914885](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516132914885.png)







# 五、字符串

## 字符串的基本概念

数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。

这里的串指的就是字符串。

串也是一种线形结构，存在一对一的关系，但串只用于存储字符数据。

**几个特殊的串**

- 空串：包含字符数为0的串
- 空格串：只包含空格的串
- 主传和子串：若在串a中有若干连续字符与串b相同，则a是b的主串，b是a的子串（子串在主串中的位置是指子串首字母在主串中出现的位置）

### 字符串的实现方式

1. 静态数组
2. 动态数组
3. 链表

#### 1、定长顺序存储结构存储字符串

使用定长顺序存储结构存储（静态数组）字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。

```c
int main() {
	char str[10] = "hello world!";
	printf("%s\n", str);
	return 0;
}
```

#### 2、堆分配存储结构存储字符串

串的堆分配存储，具体实现方式就是采用动态数组存储字符串。

```c
int main() {
    char *str1 = NULL;
    char *str2 = NULL;
    str1 = (char *)malloc(10*sizeof(char));
    str2 = (char *)malloc(10*sizeof(char));
    strcpy(str1, "hello");
    strcpy(str2, "world!");
    int str1_length = strlen(str1);
    int str2_length = strlen(str2);
    if(str1_length < str1_length + str2_length) {
        str1 = (char *)realloc(str1, (str1_length + str2_length)*sizeof(char));
    }
    for(int i = str1_length; i < (str1_length + str2_length); i++) {
        str1[i] = str2[i-str2_length+1];
    }
    str1[str1_length + str2_length] = '\0';
    printf("%s\n", str1);
    free(str1);
    free(str2);
}
```

#### 4、块链存储结构存储字符串

块链存储结构就是使用链表结构来存储字符串。链表的一个节点可以存储单个字符也可以存储若干字符。

使用块链结构存储字符串时，最后一个节点的数据域不一定会被占满，所以会i使用特殊字符进行占位。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct listString {
    char ch;
    struct listString *next;
}listString;
listString *init(char *str) {
    int node_num = strlen(str);
    listString *head = (listString *)malloc(sizeof(listString));
    head -> next = NULL;
    listString *t = head;
    for(int i = 0; i < node_num; i++) {
        listString *node = (listString *)malloc(sizeof(listString));
        node -> ch = str[i];
        node -> next = NULL;
        t -> next = node; 
        t = t -> next;
    }
    return head;
}
void display(listString *head) {
    listString *t = head -> next;
    while(t) {
        printf("%c", t -> ch);
        t = t -> next;
    }
    printf("\n");
}
int main(int argc, char *argv[]) {
    listString *head;
    head = init(argv[1]);
    display(head);
    return 0;
}
```



## 串的模式匹配算法

### BF匹配

BF模式匹配（普通模式匹配）：将两个字符串的字符逐个匹配。

#### 算法原理

![image-20220517113649388](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220517113649388.png)

#### 代码实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int BFstrMatch(char *str1, char *str2) {
    int str1_len = strlen(str1);
    int str2_len = strlen(str2);
    int i = 0, j = 0, k = 0;
    while(i < str1_len && j < str2_len) {
        k++;
        if(str1[i] == str2[j]) {
            i++;
            j++;
        }
        else {
            i = k;
            j = 0;
        }
    }
    if(j == str2_len)
        return 1;
    else
        return 0;
}

int main() {
    char str1[100], str2[100];
    scanf("%s", str1);
    scanf("%s", str2);
    int result = BFstrMatch(str1, str2);
    if(result == 1)
        printf("yes!\n");
    else
        printf("no!\n");
    return 0;
}
```



### KMP匹配









# 六、数组和广义表

## 数组

### 数组的定义

这里所指的数组是一种数据结构，要与平时使用的数组基本类型做区分。

本质上，数组和顺序表、链表、栈和队列一样，都是用来存储具有“一对一”关系的元素的线性存储结构，但特别的是，顺序表、链表、栈和队列只能用于存储不可再分的最小元素，而数组既可以存储不可再分的最小元素，也可以存储可再分的数据结构。如：多维数组。

### 数组的顺序存储

数组作为一种线性存储结构，对存储的数据通常只做查找和修改操作（因为对数组元素进行插入和删除时，需要移动大量数据，时间复杂度高），因此数组结构的实现使用的是顺序存储结构。



### 矩阵的压缩存储

#### 1、对称矩阵

矩阵中的数据元素沿主对角线对应相等，这类矩阵称为对称矩阵。如图：







## 广义表



# 七、树

## 数的基本概念

![image-20220512155306091](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512155306091.png)

**树的节点**

树存储结构中每个元素称为一个节点，包含数据域和指针域。

区别于线性表一对一的元素关系，树中的节点是一对多的关系。

**子树：**

**兄弟：**具有相同双亲的节点。

**节点的度：**节点的度即为该节点的子树数。

**叶子：**没有子树，即度为0的节点。

**树的层次：**根节点为第一层，其余节点的层次等于其双亲节点的层次加1。

**树的高度：**也叫树的深度，是树中最大层次。

**森林：**0或多棵互不相交的树的集合。

![image-20220512162445591](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512162445591.png)



## 二叉树

最多有两棵子树的树被称为二叉树。

![image-20220512163417297](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512163417297.png)

### 二叉树的性质

1. 二叉树中，第$i$层最多有$2^{i-1}$个节点。
1. 深度为$k$的二叉树最多有$2^k-1$个节点。
1. 若二叉树中叶子节点数为$n_0$，度为2的节点数为$n_2$，则：$n_0=n_2+1$。

### 二叉树的分类

**满二叉树**

如果二叉树中除了叶子结点，每个结点的度都为 2，且叶子结点都在同一层次上，则此二叉树称为满二叉树。

![image-20220512163311543](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512163311543.png)

**完全二叉树**

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

![image-20220512165026045](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512165026045.png)



### 二叉树的存储结构

**顺序存储：**使用顺序表存储二叉树结构

顺序存储只适用于完全二叉树（包括满二叉树），若要使用顺序表来存储普通二叉树，则应先将普通二叉树转换为完全二叉树。

普通二叉树转化为完全二叉树：添加节点，拼凑成完全二叉树。

![image-20220512170014282](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512170014282.png)

**完全二叉树的顺序存储：**仅需从根节点开始，按照层次依次将树中节点存储到数组。

![image-20220512170402800](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512170402800.png)

如上图 2 的完全二叉树，其存储状态如下图 3：

![image-20220512170428984](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512170428984.png)

**二叉树顺序存储的还原：**

完全二叉树具有以下性质：

将完全二叉树中的节点按层次、从左到右标号，若节点$i$有左孩子和右孩子，则节点$i$的左孩子节点为$2i$，右孩子节点为：$2i+1$。此性质可用于还原数组中存储的完全二叉树。实现此还原，需对二叉树进行层次遍历。



**链式存储**

一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。

![image-20220512171439650](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512171439650.png)

该二叉树用链式结构可表示为：

![image-20220512171510780](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512171510780.png)

链式存储的节点结构：

- 指向左孩子节点的指针（lchild）
- 节点存储的数据（data）
- 指向右孩子节点的指针（rchild）

![image-20220512171619907](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220512171619907.png)

### 二叉树的基本操作

#### 顺序存储结构实现

顺序存储只适用于完全二叉树，普通二叉树要使用顺序存储结构来存储时，必须先转换为完全二叉树，转换方法如下：

用额外的节点来和原来的二叉树拼凑出完全二叉树：

![image-20220519202200922](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220519202200922.png)



#### 链式存储结构实现

1. 定义二叉树节点数据结构

   ```c
   typedef struct treeNode {
       int data;
       struct treeNode *lchild;
       struct treeNode *rchild;
   }treeNode;
   ```

2. 先序创建二叉树

   ```c
   void create(treeNode **T, char *data, int *index) {
       char ch = data[*index];
       *index += 1;
       if(ch == '#') {
           (*T) = NULL;
       }
       else {
           (*T) = (treeNode *)malloc(sizeof(treeNode));
           (*T) -> data = ch;
           create(&((*T)->lchild), data, index);
           create(&((*T)->rchild), data, index);
       }
   }
   ```

3. 先序遍历二叉树

   ```c
   void preorder(treeNode *T) {
       if(T == NULL) {
           return;
       }
       else {
           printf("%c ", T -> data);
           preorder(T -> lchild);
           preorder(T -> rchild);
       }
   }
   ```

4. 中序遍历二叉树

   ```c
   void inorder(treeNode *T) {
       if(T == NULL) {
           return;
       }
       else {
           inorder(T -> lchild);
           printf("%c ", T -> data);
           inorder(T -> rchild);
       }
   }
   ```

5. 后序遍历二叉树

   ```c
   void postorder(treeNode *T) {
       if(T == NULL) {
           return;
       }
       else {
           postorder(T -> lchild);
           postorder(T -> rchild);
           printf("%c ", T -> data);
       }
   }
   ```

6. 测试代码

   ```c
   int main(int argc, char *argv[]) {
       treeNode *T;
       T = (treeNode *)malloc(sizeof(treeNode));
       int index = 0;
       create(&T, argv[1], &index);
       printf("先序遍历二叉树\n");
       preorder(T);
       printf("\n");
       printf("中序遍历二叉树\n");
       inorder(T);
       printf("\n");
       printf("后序遍历二叉树\n");
       postorder(T);
       printf("\n");
       return 0;
   }
   ```

7. 测试结果

   ![image-20220516144330577](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516144330577.png)

![image-20220516144353307](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220516144353307.png)

























## 哈夫曼树

### 基本概念

- 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。
- 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。
- 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。
- 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。
- 树的带权路径长度：指的是树中所有叶子结点的带权路径长度之和，通常记作 “WPL” 。

**哈夫曼树**

当用 n 个结点构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，也叫“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则：**权重越大的结点离树根越近**。

























# 八、图

## 图的基本概念

![image-20220524210442268](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220524210442268.png)

图结构：数据元素之间具有“多对多”的关系。

图存储结构中，习惯上用 Vi 表示图中的顶点，且所有顶点构成的集合通常用 V 表示，如图 1 中顶点的集合为 V={V1,V2,V3,V4}。

图的分类：图可分为“无向图”和“有向图”

![image-20220524210942009](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220524210942009.png)

**相关名词**

**顶点：**图结构中，各元素称为一个“顶点”。

**弧头和弧尾：**有向图中，无箭头一端的顶点通常被称为"初始点"或"弧尾"，箭头直线的顶点被称为"终端点"或"弧头"。

**入度和出度：**对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度；箭头远离 V 的弧的数量为 V 的出度。

**权和网：**在某些实际场景中，图中的每条边会赋予一个实数来表示一定的含义，这种与边相匹配的实数被称为"权"，而带权的图通常称为网。

![image-20220524211144829](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220524211144829.png)

**子图：**指的是由图中一部分顶点和边构成的图，称为原图的子图。



**图存储结构的分类**

1. 完全图：若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图，同时，满足此条件的有向图则称为有向完全图。

   ![image-20220524211525790](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220524211525790.png)

2. 稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边，此图就称为"稀疏图"；反之，则称此图为"稠密图"。

   稀疏和稠密的判断条件是：e<nlogn，其中 e 表示图中边的数量，n 表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。

3. 连通图：无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图。

4. 强连通图：有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，则称此有向图为强连通图。





# 九、查找算法

## 顺序查找

顺序查找的查找过程为：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。

### 1、顺序存储结构下的顺序查找

```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

//定义顺序存储结构的查找表
typedef struct List {
    char *data;
    int length;
    int MAX_SIZE;
}List;

//初始化查找表
List *init_List(int MAX_SIZE) {
    List *L = (List *)malloc(sizeof(List));
    L -> data = (char *)malloc(sizeof(char) * MAX_SIZE);
    L -> length = 0;
    L -> MAX_SIZE = MAX_SIZE;
    for(int i = 0; i < L -> MAX_SIZE; i++) {
        L -> data[i] = '\0';
    }
    return L;
}

//向查找表中添加元素
void add_to_List(List *L, char *data, int data_length) {
    int List_index = L -> length;
    for (int i = 0; i < data_length; i++) {
        L -> data[List_index] = data[i];
        L -> length += 1;
        List_index += 1;
    }
}

//遍历查找表
void display_List(List *L) {
    for (int i = 0; i < L -> length; i++) {
        printf("%c ", L -> data[i]);
    }
    printf("\n");
}

//顺序查找
int seq_search(List *L, char key) {
    int resp;
    for(int i = 0; i < L -> length; i++) {
        if(key == L -> data[i]) {
            resp = i;
            return resp;
        }
    }
    resp = -32768;
    return resp;
}

int main() {
    printf("初始化顺序查找表：");
    List *L = init_List(MAX);
    char *data = "ABCDEFG";
    add_to_List(L, data, 7);
    display_List(L);
    printf("顺序查找");
    printf("请输入要查找的字符：");
    char key = getchar();
    int resp = seq_search(L, key);
    if(resp > 0) {
        printf("字符%c在顺序查找表中的下标是:%d\n", key, resp);
    }
    else {
        printf("字符%c不在顺序查找表中\n", key);
    }
    return 0;;
}
```

### 2、链式存储结构下的顺序查找

```c
#include <stdio.h>
#include <stdlib.h>

//定义链表节点数据结构
typedef struct chainNode {
    char data;
    struct chainNode *next;
}chainNode;

//初始化链表
chainNode *init_chainList() {
    chainNode *L = (chainNode *)malloc(sizeof(chainNode));
    L -> data = '\0';
    L -> next = NULL;
    return L;
}

//向链表中添加元素（尾插法）
void add_to_chainList(chainNode *L, char *data) {
    chainNode *p = L;
    int data_index = 0;
    while (data[data_index] != '\0') {
        while (p -> next) {
            p = p -> next;   
        }
        chainNode *node = (chainNode *)malloc(sizeof(chainNode));
        node -> data = data[data_index];
        node -> next = p -> next;
        p -> next = node;
        data_index += 1;
    }
}

//遍历链表
void display_chainList(chainNode *L) {
    chainNode *p = L -> next;
    while (p) {
        printf("%c -> ", p -> data);
        p = p -> next;
    }
    printf("NULL\n");
}

int chain_search(chainNode *L, char key) {
    chainNode *p = L -> next;
    int index = 1;
    while (p) {
        if (key == p -> data) {
            return index;
        }
        index += 1;
        p = p -> next;
    }
    index = -1;
    return index;
}

int main() {
    printf("初始化链表：\n");
    chainNode *L = init_chainList();
    char *data = "ABCDEFG";
    add_to_chainList(L, data);
    display_chainList(L);
    printf("顺序查找：\n");
    printf("请输入要查找的字符:");
    char key = getchar();
    int resp = chain_search(L, key);
    if(resp > 0) {
        printf("字符%c在链表中的第%d个节点\n", key, resp);
    }
    else {
        printf("字符%c不在链表中\n", key);
    }
    return 0;
}
```



## 二分查找

使用二分查找的前提是待查找的序列有序。

二分查找（折半查找）的过程

![image-20220612210425466](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220612210425466.png)

代码实现：

```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

//定义查找表结构
typedef struct List {
    int *data;
    int length;
}List;

//创建查找表
List *create_List(List *L, int data[], int data_num) {
    L = (List *)malloc(sizeof(List));
    L -> data = (int *)malloc(sizeof(int) * data_num);
    L -> length = data_num;
    for (int i = 0; i < data_num; i++) {
        L -> data[i] = data[i];
    }
    return L;
}

//遍历查找表
void display_List(List *L) {
    for (int i = 0; i < L -> length; i++) {
        printf("%d ", L -> data[i]);
    }
    printf("\n");
}

//二分查找
int bin_search(List *L, int key) {
    int head = 0;
    int tail = L -> length - 1;
    int mid = (head + tail) / 2;
    while (head <= tail) {
        if (key == L -> data[mid]) {
            return mid;
        }
        else if (key < L -> data[mid]) {
            tail = mid - 1;
            mid = (head + tail) / 2;
        }
        else {
            head = mid + 1;
            mid = (head + tail) / 2;
        }
    }
    return -1;
}

int main() {
    printf("创建查找表:");
    int data[10] = {1,2,3,4,5,6,7,8,9,10};
    List *L = create_List(L, data, 10);
    display_List(L);
    printf("二分查找:\n");
    printf("请输入要查找的数:");
    int key,resp;
    scanf("%d", &key);
    resp = bin_search(L, key);
    if (resp > 0) {
        printf("元素%d在查找表中的下标是:%d\n", key, resp);
    }
    else {
        printf("元素%d不在查找表中\n", key);
    }
    return 0;
}
```



## 二叉排序树（BST）

二叉排序树是动态查找表的一种实现方式，动态查找表中做查找操作时，若查找成功可以对其进行删除；如果查找失败，即表中无该关键字，可以将该关键字插入到表中。

### 二叉排序树的概念

二叉排序树要么是空二叉树，要么具有如下特点：

1. 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值
2. 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大小根结点的值
3. 二叉排序树的左右子树也要求都是二叉排序树

![image-20220612214325893](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20220612214325893.png)

使用二叉排序树时，元素不能有重复的值，否则会插入失败。

代码实现：

```c
#include <stdio.h>
#include <stdlib.h>

//定义二叉排序树结构
typedef struct bsTree {
    int data;
    struct bsTree *lchild;
    struct bsTree *rchild;
}bsTree;

//向二叉排序树的节点插入元素
void insert(bsTree **T, int data) {
    if (*T == NULL) {
        (*T) = (bsTree *)malloc(sizeof(bsTree));
        (*T) -> data = data;
        (*T) -> lchild = NULL;
        (*T) -> rchild = NULL;
    }
    else if (data == (*T) -> data) {
        return;
    }
    else if ((data < (*T) -> data)) {
        insert(&((*T) -> lchild), data);
    }
    else {
        insert(&((*T) -> rchild), data);
    }
}

//在二叉排序树中查找指定元素
bsTree *search(bsTree *T, int key) {
    if (T) {
        if (key == T -> data) {
            return T;
        }
        else if (key < T -> data) {
            return search(T -> lchild, key);
        }
        else {
            return search(T -> rchild, key);
        }
    }
    else {
        return NULL;
    }
}

//先序遍历二叉排序树
void preOrder(bsTree *T) {
    if (T == NULL) {
        return;
    }
    else {
        printf("%d ", T -> data);
        preOrder(T -> lchild);
        preOrder(T -> rchild);
    }
}

int main() {
    printf("初始化二叉排序树并先序遍历:");
    bsTree *T = NULL;
    int num_list[6] = {4, 5, 19, 23, 2, 8};
    for (int i = 0; i < 6; i++) {
        insert(&T, num_list[i]);
    }
    preOrder(T);
    printf("\n");
    printf("请输入要查找的元素:");
    int key;
    scanf("%d", &key);
    bsTree *resp = search(T, key);
    printf("%d\n", resp -> data);
    return 0;
}
```





























``
