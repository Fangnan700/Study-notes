# 五大常用算法



## 一、分治算法

### 什么是分治算法？

字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，子问题的解的合并即为原问题的解。



### 分治算法的基本思想？

分治法的设计思想是：将一个难以直接解决的大问题，分割成一系列规模较小的相同问题，再对这些小问题逐个解决。

![image-20221011192609329](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221011192609329.png)



### 分治算法的实现思路？

在分治算法的思想下，分解出来的小问题与原问题类型相同，只是规模变得更小，因此，可以考虑使用递归的思想来实现分治算法。

分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。



### 分治算法的适用情况？

分治法所能解决的问题一般具有以下几个特征：

1） 该问题的规模缩小到一定的程度就可以容易地解决；

2） 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；

3） 利用该问题分解出的子问题的解可以合并为该问题的解；

4） 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。



### 分治算法的基本步骤？

分治法在每一层递归上都有三个步骤：

step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；

step3 合并：将各个子问题的解合并为原问题的解。



### 分治算法的经典问题？

#### 1、二分查找



**二分查找算法基本思想** 

二分查找算法的前置条件是：一个已经排序好的序列。这样在查找所要查找的元素时，首先与序列中间的元素进行比较，如果大于这个元素，就在当前序列的后半部分继续查找；如果小于这个元素，就在当前序列的前半部分继续查找，直到找到相同的元素，或者所查找的序列范围为空为止。



**非递归实现**

问题：在给定的升序序列中，搜索一个数，如果存在，返回其索引，否则返回 -1。

C++实现：

```c++
#include <iostream>
using namespace std;

int binary_Search(int nums[], int nums_len , int target) {
    int left, mid, right;
    left = 0;
    right = nums_len;
    while(left <= right) {
        mid = (left + right ) / 2;
        if(target == nums[mid]) {
            return mid;
        } else if(target > nums[mid]) {
            left = mid;
        } else if(target < nums[mid]) {
            right = mid;
        }
    }
    return -1;
}

int main() {
    int nums[] = {0,1,2,3,4,5,6,7,8,9};
    //当把数组作为参数传递给函数时，它会衰退为一个指向数组第一个元素的指针，丢失数组的长度信息，所以数组的长度必须在传入函数前计算好
    int index = binary_Search(nums, sizeof(nums) / sizeof(int), 7);
    cout << index << endl;
    return 0;
}
```

Java实现：

```java
public class binarySearch_non_recursive {

    static int binary_Search(int[] nums, int target) {
        int left, mid, right;
        left = 0;
        right = nums.length;
        while(left <= right) {
            mid = (left + right) / 2;
            if(target == nums[mid]) {
                return mid;
            } else if(target > nums[mid]) {
                left = mid;
            } else if(target < nums[mid]) {
                right = mid;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {0,1,2,3,4,5,6,7,8,9};
        int target = 5;
        int index = binary_Search(nums, target);
        System.out.println("The target's index is " + index);
    }
}
```



**递归实现**

C++实现：

```c++
#include <iostream>
using namespace std;

int binarySearch(int nums[], int target, int left, int right) {
    //基线条件
    if(left == right)
        return left;
    
    //递归条件
    if(left < right) {
        int mid = (left + right) / 2;
        if(target < nums[mid]) {
            return binarySearch(nums, target, left, mid);
        } else if(target > nums[mid]) {
            return binarySearch(nums, target, mid, right);
        } else {
            return mid;
        }
    }
    return -1;
}

int main() {
    int nums[] = {0,1,2,3,4,5,6,7,8,9};
    int nums_len = sizeof(nums) / sizeof(int);
    int target = 7;
    int index = binarySearch(nums, target, 0, nums_len);
    cout << "The target's index is " << index << endl;
    return 0;
}
```



Java实现：

```java
public class binarySearch_recursive {

    static int binary_Search(int[] nums, int target, int left, int right) {
        //基线条件
        if(left == right) {
            return left;
        }

        //递归条件
        if(left < right) {
            int mid = (left + right) / 2;
            if(target < nums[mid]) {
                return binary_Search(nums, target, left, mid);
            } else if(target > nums[mid]) {
                return binary_Search(nums, target, mid, right);
            } else {
                return mid;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {0,1,2,3,4,5,6,7,8,9};
        int target = 5;
        int index = binary_Search(nums, target, 0, nums.length);
        System.out.println("The target's index is " + index);
    }
}
```





#### 2、快速排序



**快速排序的基本思想**

快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：快排每一趟会选定一个数，将比这个数小的放左面，比这个数大的放右面，然后递归分治求解两个子区间，当全部分到最底层的时候这个序列的值就是排序完的值。



**C++实现：**

```

```







## 二、贪心算法



### 什么是贪心算法？

贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。

贪心算法选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。



### 贪心算法的基本思想？

贪心两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。



### 贪心算法的基本步骤？

步骤1：从某个初始解出发；
步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；
步骤3：将所有解综合起来。















