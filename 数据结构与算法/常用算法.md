# 常用算法



## 枚举算法

在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么该结论是可靠的，这种归纳方法叫做枚举法。

枚举算法的思想是：将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，舍弃不合适的。

枚举算法的流程图：

![image-20221023103641070](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221023103641070.png)



**枚举算法的经典问题**

**百钱买百鸡**

公鸡每只5元，母鸡每只3元，三只小鸡1元，用100元买100只鸡，问公鸡、母鸡、小鸡各多少只？

**问题分析**

利用枚举法解决该问题，以三种鸡的个数为枚举对象,分别设为 mj，gj 和 xj，用三种鸡的总数 （mj+gj+xj=100）和买鸡钱的总数（1/3*xj+mj*3+gj*5=100）作为判定条件，穷举各种鸡的个数。

C++实现：

```cpp
#include <iostream>
using namespace std;

int main() {
    int gj, mj, xj;
    for(gj = 1; gj <= 20; gj++) {
        for(mj = 1; mj <= 33; mj ++) {
            for(xj = 1; xj <= 300; xj++) {
                if(gj + mj + xj == 100 && 5*gj + 3*mj + 1/3*xj == 100) {
                    cout << "公鸡:" << gj << "，母鸡:" << mj << "，小鸡:" << xj << endl;
                }
            }
        }
    }
    return 0;
}
```









## 递推算法

递推算法能通过已知某个条件，利用特定的关系得出中间推论，然后逐步递推，直到得到结果为止。

（1）顺推法：从已知条件出发，逐步推算出要解决的方法。

（2）逆推法：从已知的结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。

**递推算法的经典问题**

裴波那契数列：

在数学上，斐波纳契数列以如下被以的方法定义：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N）

```cpp
#include <iostream>
using namespace std;

int main() {
    int p1 = 0;
    int p2 = 1;
    int tmp;
    int N;
    cin >> N;
    cout << "第1项:0" << endl;
    cout << "第2项:1" << endl;
    for(int i = 2; i < N; i++) {
        tmp = p1 + p2;
        p1 = p2;
        p2 = tmp;
        cout << "第" << i << "项:" << tmp << endl;
    }
    return 0;
}
```










## 递归算法

递归算法是一种直接或者间接调用自身函数或者方法的算法。说简单了就是程序自身的调用。递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解，即用同一个方法去解决规模不同的问题，这也是分治算法的思想，实际上分治算法的实现就经常使用递归。

**递归的经典问题**

汉诺塔问题

![image-20221104155929017](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221104155929017.png)

问题的提出：Hanoi塔由n个大小不同的圆盘和三根木柱a,b,c组成，这n个圆盘由大到小依次套在a柱上。若要求：

- 一次只能移一个圆盘
- 圆盘只能在三个柱上存放
- 在移动过程中，不允许大盘压小盘

问将这n个盘子从a柱移动到c柱上，总计需要移动多少个次？

题目分解：

1. 将n个圆盘从小到大依次编号1~n
2. 将1~n-1移到B柱，n移动到C柱
3. 将1~n-2移到A柱，n-1移到C柱
4. 将1~n-3移到B柱，n-2移到C柱
5. 依次类推，直到将1移到C柱

这里的分解体现了将大规模的问题分解成类型相同的小规模问题，分别求解。





















## 分治算法



字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，子问题的解的合并即为原问题的解。

分治法的设计思想是：将一个难以直接解决的大问题，分割成一系列规模较小的相同问题，再对这些小问题逐个解决。

![image-20221011192609329](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221011192609329.png)





在分治算法的思想下，分解出来的小问题与原问题类型相同，只是规模变得更小，因此，可以考虑使用递归的思想来实现分治算法。

分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。



分治法所能解决的问题一般具有以下几个特征：

1） 该问题的规模缩小到一定的程度就可以容易地解决；

2） 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；

3） 利用该问题分解出的子问题的解可以合并为该问题的解；

4） 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。



分治法在每一层递归上都有三个步骤：

step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；

step3 合并：将各个子问题的解合并为原问题的解。



**分治算法的经典问题**

**二分查找**

二分查找算法基本思想 

二分查找算法的前置条件是：一个已经排序好的序列。这样在查找所要查找的元素时，首先与序列中间的元素进行比较，如果大于这个元素，就在当前序列的后半部分继续查找；如果小于这个元素，就在当前序列的前半部分继续查找，直到找到相同的元素，或者所查找的序列范围为空为止。



非递归实现

问题：在给定的升序序列中，搜索一个数，如果存在，返回其索引，否则返回 -1。

C++实现：

```cpp
#include <iostream>
using namespace std;

int binary_Search(int nums[], int nums_len , int target) {
    int left, mid, right;
    left = 0;
    right = nums_len;
    while(left <= right) {
        mid = (left + right ) / 2;
        if(target == nums[mid]) {
            return mid;
        } else if(target > nums[mid]) {
            left = mid;
        } else if(target < nums[mid]) {
            right = mid;
        }
    }
    return -1;
}

int main() {
    int nums[] = {0,1,2,3,4,5,6,7,8,9};
    //当把数组作为参数传递给函数时，它会衰退为一个指向数组第一个元素的指针，丢失数组的长度信息，所以数组的长度必须在传入函数前计算好
    int index = binary_Search(nums, sizeof(nums) / sizeof(int), 7);
    cout << index << endl;
    return 0;
}
```





递归实现

C++实现：

```cpp
#include <iostream>
using namespace std;

int binarySearch(int nums[], int target, int left, int right) {
    //基线条件
    if(left == right)
        return left;
    
    //递归条件
    if(left < right) {
        int mid = (left + right) / 2;
        if(target < nums[mid]) {
            return binarySearch(nums, target, left, mid);
        } else if(target > nums[mid]) {
            return binarySearch(nums, target, mid, right);
        } else {
            return mid;
        }
    }
    return -1;
}

int main() {
    int nums[] = {0,1,2,3,4,5,6,7,8,9};
    int nums_len = sizeof(nums) / sizeof(int);
    int target = 7;
    int index = binarySearch(nums, target, 0, nums_len);
    cout << "The target's index is " << index << endl;
    return 0;
}
```







**快速排序**

快速排序的基本思想

快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：快排每一趟会选定一个数，将比这个数小的放左面，比这个数大的放右面，然后递归分治求解两个子区间，当全部分到最底层的时候这个序列的值就是排序完的值。



**C++实现：**

```cpp

```





## 回溯算法

从本质上看，回溯算法与DFS（深度优先遍历）基本上一致，都是一种暴力穷举的思想。回溯算法和DFS都可以理解成是对多叉树的遍历，两者唯一的区别在于，回溯算法关心的是遍历的路径，而DFS关心的是遍历的节点。

在使用回溯算法解决问题时，可以将问题表示成一颗“决策树”，每条遍历路径对应一种解决方案，在遍历这棵决策树的时候，只需要站在某个节点上考虑当前节点需要做的事情，在遍历到其它节点的时候，进行的操作是完全一致的。

在回溯算法中需要注意的三个概念：

- 已选列表：代表着遍历到当前节点之前已经做出的选择
- 可选列表：代表当前节点上进行下一步时可以选择的路径
- 结束条件：代表到达决策树的叶子节点时，开始进行回溯



**回溯算法的基本框架**

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



**实例一：[力扣46题：全排列	](https://leetcode.cn/problems/permutations/)**

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]


提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同



解题思路：

根据框架，先将决策树画出：

![image-20221113150752272](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221113150752272.png)

回溯算法关心的是遍历的路径，可以发现，在决策树中，每一条由根节点出发到叶子节点的遍历路径就对应着一种全排列，所以只需要对决策树进行遍历即可。

在遍历的过程中，遍历到每一个节点时，都需要做出“选择”，决定下一步该往哪一个方向遍历，所以使用最简单的递归方式，只需要考虑在一个节点上需要做哪些操作即可。

回溯算法中的已选列表和可选列表就是为了帮助在节点上做选择而存在的，需要实时维护。



代码实现：

```cpp
class Solution {
public:

    // 定义用于存储最终结果的数组
    vector<vector<int>> result;

    // 主函数，用于返回最终结果
    vector<vector<int>> permute(vector<int>& nums) {
        // 定义用于存储一条路径上的全排列选择
        vector<int> track;

        // 从根节点开始遍历
        backTrack(nums, track);

        // 返回最终结果
        return result;
    }

    // 回溯遍历函数
    void backTrack(vector<int>& nums, vector<int>& track) {
        // 设置终止条件（开始回溯的条件），即到达叶子节点
        if(track.size() == nums.size()) {
            // 将当前路径构成的全排列加入结果中
            result.push_back(track);
            return;
        }

        // 对当前节点的每个子树都进行相同的遍历操作
        for(int i = 0; i < nums.size(); i++) {
            // 排除已经选择过的节点
            if(find(track.begin(), track.end(), nums[i]) != track.end()) {
                continue;
            }

            // 前序位置，做出选择
            track.push_back(nums[i]);

            backTrack(nums, track);

            // 后序位置，撤销选择
            track.pop_back();
        }
    }
};
```

从这道题可以知道，回溯算法的关键在于，在遍历决策树的时候，需要在递归之前做出选择，在递归之后撤销选择，以实现“回溯”。







## 贪心算法

贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。

贪心算法选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。



贪心两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。



贪心算法的基本步骤：

步骤1：从某个初始解出发；
步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；
步骤3：将所有解综合起来。









## 动态规划

**动态规划常见的题目**

一、计数

- 求矩阵上从某点走到某点有多少中方式
- 求有多少中方式选出k个数使得这k个数的和是n

二、求最值

- 求矩阵上某点到某点路径的最大数字和
- 求最长上升子序列长度

三、求存在性

- 取石子游戏，先手是否必胜
- 是否能选出k个数使得和是n



**动态规划解题步骤**

一、确定状态：

1. 使用动态规划解决问题时，一般需要开辟数组，就要先确定数组中的每个元素代表什么
2. 确定最后一步，对应最优策略的最后一步策略
3. 确定子问题，即去除最后一步策略后的问题













