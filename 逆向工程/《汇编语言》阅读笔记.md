# 第一章 基础知识

## 1.1 什么是汇编语言？

**汇编语言的产生**

由于机器语言（二进制代码）的可读性几乎为0，用于替代机器语言的汇编语言应运而生，提高了代码的可读性，便于程序员理解和修改。



**使用汇编语言编写程序的过程**

```
程序员 ---（汇编指令）--> 编译器 ---（机器码）--> 计算机
```



**汇编语言的组成**

- 汇编指令：机器码的助记符，每个汇编指令对应一个机器码；
- 伪指令：由编译器来执行
- 其它符号

*汇编指令是汇编语言的主体、核心。



## 1.2 存储器

CPU是计算机的核心部件，用于控制整个计算机的运行，而CPU工作所需的指令和数据则在存储器中存放。

存储器分为内存和外存：内存直接与CPU交互，外存中的数据则需先行加载到内存中，才能被CPU所使用。



## 1.3 存储单元

存储器被划分为连续的若干个存储单元，使用下标对每个存储单元进行编号（从0开始）。

**最小单位**

计算机中的最小单位是 bit（比特），1 bit = 1个二进制位

**基本单位**

计算机存储单元是以字节（Byte）作为基本单位的，1 Byte = 8 bit，一般使用 B 来表示Byte

**单位换算**

- 1 B = 8 bit
- 1 KB = 1024 B
- 1 MB = 1024 KB
- 1 GB = 1024 MB
- 1 TB = 1024 GB
- 1 PB = 1024 TB



## 1.4 CPU对存储器的读写

CPU想要实现对存储器的读写，就必须和存储器进行以下3种数据的交互：

- 地址信息：要操作的存储单元的地址
- 控制信息：器件的选择和读或写操作
- 数据信息：要读或写的数据



**总线**

总线分为两类：

- 内部总线：用于实现CPU内部各个器件之间的通信
- 外部总线：用于实现CPU与外部器件的通信

总线是CPU与外部器件通信的通道，有以下3种类型：

- 地址总线：用于传输CPU要操作的存储单元的地址信息
- 控制总线：用于传输CPU对器件的指令
- 数据总线：用于传输要操作的数据

![image-20221012235922938](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221012235922938.png)





# 第二章 寄存器

一般的CPU包含以下器件：

- 运算器：实现对数据的处理
- 控制器：协调控制各个器件的工作
- 寄存器：存储CPU要处理的数据
- 总线：在各个器件之间传输数据



寄存器是CPU中程序员可以直接控制的器件，改变不同寄存器中的内容就可以实现对CPU的控制。

8086CPU中，所有的寄存器都是16位的，可以存放两个字节的数据。

![image-20221203214700725](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203214700725.png)



## 2.1 通用寄存器

通用寄存器通常用来存放一般性的数据，如运算过程中的变量等。

8086CPU中的通用寄存器有：AX、BX、CX、DX。

为了兼容上一代使用8位寄存器的CPU，8086CPU中的每个通用寄存器都可分为两个独立的寄存器来使用，如：

- AX可分为AH和AL
- BX可分为BH和BL
- CX可分为CH和CL
- DX可分为DH和DL

![image-20221203214716860](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203214716860.png)

\*AH称为高8位寄存器，AL称为低8位寄存器。





## 2.2 字在寄存器中的存储

**字和字节**

- 字节（byte）：1个字节由8个bit（二进制位）组成，可以存储在一个8位寄存器中。
- 字（word）：一个字由两个字节组成，按照这两个字节在寄存器中的存储位置，可分为高字节和低字节：

![image-20221203214754456](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203214754456.png)



## 2.3 几条汇编指令

![image-20221203215028346](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203215028346.png)

（这里先大致了解mov、add两条指令的作用）





## 2.4 16位CPU

16位CPU具有以下特性：

- 运算器一次最多处理16位的数据
- 寄存器的最大宽度为16位
- 运算器和寄存器之间的通路（总线）最大宽度为16位

8086CPU一次可以处理两种类型的数据：

- 字节型数据：byte  8bit～8位寄存器
- 字型数据：1个字=2个字节  16bit～16位寄存器

在操作数据时，要保证数据和寄存器的位数一致。



## 2.5 物理地址

在内存的存储空间中，所有内存单元组成一个一维的线性空间，按照从低到高依次编号，每个存储单元的编号就是这个存储单元唯一的地址，称为物理地址，CPU访问内存单元时，就是通过地址总线发出要访问的内存单元的物理地址来进行的。

CPU在通过地址总线向存储器发出物理地址前，会先在CPU内部形成要访问内存单元的物理地址。不同架构的CPU生成物理地址的方式不同。





## 2.6 8086CPU生成物理地址的方法

由于8086CPU内部的地址总线宽度是20位的，为了更好的利用资源，8086CPU采用将两个16位地址合成的方式给出一个20位的物理地址。

先看8086CPU的内部结构：

![image-20221203220317504](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203220317504.png)

**8086CPU给出物理地址的过程：**

1. CPU内部需要访问内存的部件给出两个16位地址（一个成为段地址，一个称为偏移地址）
2. 段地址和偏移地址送入地址加法器
3. 地址加法器将段地址和偏移地址合成为一个20位的物理地址
4. 地址加法器将合成好的20位物理地址送入输入输出控制电路
5. 输入输出控制电路将20位物理地址通过地址总线发送到存储器

**8086CPU地址加法器的合成方法：**

- 物理地址=段地址x16偏移地址

```
这里的段地址x16可以这么理解：

在使用二进制表示时，乘以16相当于乘以2的4次方，也就是二进制位最高位会向左移动4位：
			  00001000 ------x16----->  10000000
			  
在使用16进制表示时，就是最高位左移一位。
```





## 2.7 ”段地址x16+偏移地址=物理地址“ 的本质含义

”用一个基础地址（段地址）和一个相对于基础地址的偏移地址来表示一个物理地址。“

可以这么理解：

```
要表示一个20位的物理地址：
	11112222222222222222
但是8086CPU的最大位宽是16位，不能一次表示完20位的物理地址；
所以约定一个规则，使用两个16位的地址（段地址和偏移地址）来表示：
段地址：
	1111000000000000
	
偏移地址：
	2222222222222222
	
段地址先乘以16（二进制左移4位），然后和偏移地址相加：
	11110000000000000000
+	    2222222222222222
——————————————————————————
	11112222222222222222
	
最终得到一个20位的物理地址。
```





## 2.8 段的概念

**误区：内存被分成一个一个的段，每一段有一个段地址。**

段的概念来自于CPU生成物理地址的方式，即：“段地址x16+偏移地址”。

**正确理解：**

在实际应用中，将若干地址连续的内存空间看作一个“段”，用“段地址x16”作为这个段的起始地址，用“偏移地址”定位这个段中的某个内存单元。例如：

![image-20221203225539477](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221203225539477.png)

**左图：**

10000H～100FF这段内存空间作为一个段，段地址就是1000H，起始地址为段地址x16，即10000H。

**右图：**

10000H～1007FH、10080H～100FFH这两段内存空间看作两个段，段地址分别为1000H和1008H。



**注意事项：**

一个段的起始地址=段地址x16，所以一个段的起始地址必然是16的倍数；

偏移地址是16位，表示的最大范围是 2^16=65536 byte，即64Kb，所以一个段的最大长度是64Kb。





## 2.9 段寄存器

8086CPU在访问内存时，需要给出两个16位的地址来合成一个20位的物理地址。其中，提供段地址的部件是段寄存器。8086CPU有4个段寄存器：

- CS
- DS
- SS
- ES

当需要访问内存时，就先读取段寄存器中提供的段地址。





## 2.10 CS和IP

**CS和IP是8086CPU中最重要的两个寄存器。**

CS是段寄存器，IP是指令指针寄存器。

也可以理解为：CS中存储的是段地址，IP中存储的是偏移地址。

存储在内存中的数据可能是指令，也可能是待处理的数据，为了区分，在8086CPU中，CPU将CS:IP指向的内容当作指令来执行。

也可以说：在任一时刻，设CS寄存器中的内容为m，IP寄存器中的内容为n，则8086CPU会读取地址为m*16+n的内存空间中的内容并将这段内容当作一个指令来执行。（如图）

![image-20221204144139614](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204144139614.png)

图中的运行流程：

1. CS中存储的段地址为2000H，IP中存储的偏移地址为0000H

   ![image-20221204144818574](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204144818574.png)

2. 将CS和IP中的两个地址送入地址加法器，合成物理地址2000H*16+0000H=20000H

   ![image-20221204144841191](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204144841191.png)

3. 将合成的物理地址20000H送入输入输出控制电路

   ![image-20221204144924760](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204144924760.png)

4. 输入输出控制电路将物理地址20000H送上地址总线

   ![image-20221204145114219](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204145114219.png)

5. 存储器获取地址总线传来的物理地址，读取起始地址为20000H的单元中的数据并将数据送上数据总线

   ![image-20221204165956092](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204165956092.png)

6. 来自内存20000H单元的指令 B8 23 01 被送入CPU

7. 输入输出控制电路将指令 B8 23 01 写入指令缓冲器

   ![image-20221204170119861](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221204170119861.png)

8. CPU每读取一条指令，偏移地址中的值就自动增加，以便读取下一条指令

9. 指令从指令缓冲器送入执行控制器并被执行

......



## 2.11 修改CS、IP的指令

8086CPU所执行的指令是由CS、IP中的内容所决定的，我们可以通过改变CS、IP中的内容来控制CPU所执行的指令。

8086CPU中的大部分寄存器的值都可以通过 mov 指令来进行改变，mov 指令称为“传送指令”。

但是，**mov指令不能用于改变CS、IP寄存器的值！！！**

要修改CS、IP寄存器的值，需要通过指令 jmp ，也叫转移指令。用法如下：

- 同时修改CS、IP的值：
  - jmp 段地址:偏移地址    --->   段地址用于修改CS、偏移地址用于修改IP
- 只修改IP的值：
  - jmp IP:某一合法寄存器   --->   用某一合法寄存器的值来修改IP



## 2.12 代码段

在8086CPU中，可以根据需要，将一组内存单元定义成一个段，并将一组长度小于等于64KB的代码存储在这段地址连续的内存单元中，这段内存就被称为一个代码段。

若要让CPU执行这段代码，就要让CPU将这段内存空间中的数据当作指令看待。方式如下：

- 修改CS:IP使其指向这段内存空间的起始地址



**小结：**

![image-20221213091040907](https://yvling-typora-image-1257337367.cos.ap-nanjing.myqcloud.com/typora/image-20221213091040907.png)



















